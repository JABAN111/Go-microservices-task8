# Использование внешнего API. Формирование базы данных.
## Цель
Создать микросервис, который будет скачивать информацию о комиксах с сайта https://xkcd.com
и сохранять ее в своей базе данных (Postgres) в удобном для поиска формате.

Mикросервис update должен при запуске создавать нужные таблицы в DB, если таковые не созданы,
отвечать по gRPC протоколу в API gateway (proto файл содержит все необходимое). Нужно реализовать
методы RPC в update и соответсвующие REST вызовы в API gateway:


1. По запросу "GET /api/ping" gateway отдает ответ о состоянии поисковых сервисов.
При таком запросе gateway запрашивает по gRPC состояния других микросервисов.
Ответ должен быть в виде JSON:
```
{
    "replies": [
        "words": "ok",
        "update": "ok"
    ]
}
```

2. По запросу "GET /api/db/stats gateway должен отдавать статистику из базы данных и
сайта XKCD ответом JSON:
```
{
    "words_total": 0,
    "words_unique": 0,
    "comics_fetched": 0,
    "comics_total": 3043
}
```
Указан пример ответа при пустой базе на момент создания этого задания. Чтобы узнать, сколько
всего комиксов находится в XKCD, обратитесь GET-запросом на https://xkcd.com/info.0.json .

3. По запросу "POST /api/db/update" следует синхроно запустить в сервисе update идемпотентное
обновление базы комиксов (скачиваем только те, которых не хватает). Комиксы хранятся в XKCD
по адресам следующего вида - https://xkcd.com/777/info.0.json , где 777 - номер комикса. Вам
необходимо сохранить в базе информацию об URL картинки, ID комикса и ключевые слова, которые
предварительно нужно отфильтровать и нормализовать в сервисе words, для каждого обработанного
комикса.
Попробуйте использовать "многопоточность" для вытаскивания комиксов с сайта, например в 10 горутин. 

4. Если запустить обновление базы в update одновременно через два cURL (Postman, etc), то одно
из них должно продолжиться, а другой запрос должен возвратить статус HTTP Accepted.

5. При отсутствии процесса обновления на запрос "GET /api/db/status" возвращается JSON вида
```
{
    "status": "idle"
}
```
Если обновление запущено, возвращаем статус "running".

Вам дана структура проекта с частичной имплементацией (пример, можно переделать) в виде популярной
архитектуры Ports & Adapters, она же гексагональная архитектура. Такая архитектура предполагает
принцип инверсии зависимостей. Попробуйте этот принцип реализовать в разрабатываемом сервисе,
а также в API gateway.

Сервисы должены собираться и запускаться через предоставленный compose файл,
а также проходить интеграционные тесты - запуск специального тест контейнера.

## Критерии приемки

1. Микросервисы компилируются в docker image-ы, запускаются через compose файл и проходят тесты.
2. Можно использовать код из предыдущего задания.
3. Сервис update конфигурируeтся через cleanenv пакет и должeн уметь запускаться как с config.yaml
файлом через флаг -config, так и через переменные среды, в этом задании - 
UPDATE_ADDRESS, DB_ADDRESS, XKCD_URL, XKCD_CONCURRENCY, WORDS_ADDRESS.
4. Используется golang 1.23+, slog логгер.

## Материалы для ознакомления

- [Signals](https://gobyexample.com/signals
- [Exit](https://gobyexample.com/exit
- [Worker Pool](https://gobyexample.com/worker-pools) 
- [Context](https://golangbot.com/context-timeout-cancellation/)
- [Migrate](https://github.com/golang-migrate/migrate/blob/master/GETTING_STARTED.md)
- [Migrate Postgres](https://github.com/golang-migrate/migrate/blob/master/database/postgres/TUTORIAL.md)
- [Pgx](https://github.com/jackc/pgx)
- [Go SQL](http://go-database-sql.org/)
- [sqlx](http://jmoiron.github.io/sqlx/)
